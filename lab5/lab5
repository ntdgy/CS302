1. 在fork()系统调用成功后，父进程会得到子进程的PID，而子进程会得到0。因此，可以通过判断PID是否为0来确定当前进程是父进程还是子进程。关于进程的执行顺序，是不确定的。

2. 子进程会变成孤儿进程，被init进程收养。

3. ![image-20230315145053549](pic/image-20230315145053549.png)
   ![image-20230315145141137](pic/image-20230315145141137.png)
   
4. ![image-20230315154824026](pic/image-20230315154824026.png)

   这条指令的作用是创建一个内核线程，该线程的入口函数是init_main，它的参数为"Hello world!!"和0。

   在这条指令中，init_main函数被作为创建线程的入口函数，"Hello world!!"作为参数传递给init_main函数，0则表示该线程不共享进程空间，即是一个独立的线程。

   

5. 当一个进程调用fork系统调用时，会进入内核空间执行do_fork函数。在do_fork函数中，会创建新的进程并设置它的context。当do_fork函数成功创建新进程后，会调用forkret函数，将新进程的返回值放到eax寄存器中，并将栈顶指针esp设置为新进程的内核栈顶。forkrets函数会从栈中读取父进程的状态，包括寄存器的值和栈指针的值，然后将它们装入对应的寄存器和内存地址中。最后，它会调用iret指令，将控制权切换回父进程，继续执行父进程的代码。

   

   